{
  "analysis_time": "2025-09-16 04:54:28",
  "issues_found": {
    "sync_javascript": {
      "count": 7,
      "description": "å‘ç°7å¤„åŒæ­¥JavaScriptè°ƒç”¨ï¼Œä¼šé˜»å¡UIçº¿ç¨‹",
      "severity": "HIGH",
      "examples": [
        "runJavaScript(self.JS_EXTRACT_SINGLE_PAGE_DETAIL, \n            lambda result, idx=tab_index: self.handle_single_result_data(result, idx)",
        "runJavaScript(js_get_count, \n            lambda count, idx=tab_index, prev_c=previous_count: self._handle_count_check(count, prev_c, idx)",
        "runJavaScript(js_pre_check, \n            lambda result, idx=tab_index: self._handle_pre_check_result(result, idx)"
      ]
    },
    "qtimer_overuse": {
      "count": 7,
      "description": "å‘ç°7å¤„QTimer.singleShotè°ƒç”¨ï¼Œå¯èƒ½é€ æˆä¸»çº¿ç¨‹é˜»å¡",
      "severity": "MEDIUM",
      "examples": [
        "QTimer.singleShot(500,",
        "QTimer.singleShot(500,",
        "QTimer.singleShot(500,"
      ]
    },
    "scroll_polling": {
      "count": 6,
      "description": "å‘ç°6å¤„æ»šåŠ¨è½®è¯¢æ¨¡å¼ï¼Œé¢‘ç¹DOMæŸ¥è¯¢ä¼šå¯¼è‡´å¡é¡¿",
      "severity": "HIGH",
      "examples": [
        "_scroll_and_wait",
        "_scroll_and_wait",
        "_scroll_and_wait"
      ]
    }
  },
  "fix_plan": {
    "immediate_fixes": [
      {
        "title": "å¼‚æ­¥åŒ–JavaScriptæ‰§è¡Œ",
        "description": "å°†æ‰€æœ‰runJavaScriptè°ƒç”¨æ”¹ä¸ºå¼‚æ­¥æ¨¡å¼",
        "implementation": "\n# æ›¿æ¢åŒæ­¥è°ƒç”¨\n# åŸä»£ç ï¼š\nbrowser_view.page().runJavaScript(js_code, callback)\n\n# ä¿®å¤ä»£ç ï¼š\ndef async_js_executor(js_code, callback, timeout=5):\n    result_container = {'result': None, 'completed': False}\n    \n    def internal_callback(result):\n        result_container['result'] = result\n        result_container['completed'] = True\n        if callback:\n            callback(result)\n    \n    # åœ¨ä¸»çº¿ç¨‹ä¸­æ‰§è¡Œ\n    QTimer.singleShot(0, lambda: browser_view.page().runJavaScript(js_code, internal_callback))\n    \n    # å¼‚æ­¥ç­‰å¾…ç»“æœ\n    start_time = time.time()\n    while not result_container['completed'] and time.time() - start_time < timeout:\n        QApplication.processEvents()  # ä¿æŒUIå“åº”\n        time.sleep(0.01)\n    \n    return result_container.get('result')\n                ",
        "priority": "HIGH"
      },
      {
        "title": "å®ç°æ»šåŠ¨èŠ‚æµæœºåˆ¶",
        "description": "é™åˆ¶æ»šåŠ¨é¢‘ç‡ï¼Œé¿å…è¿‡åº¦é¢‘ç¹çš„æ»šåŠ¨æ“ä½œ",
        "implementation": "\nclass ScrollThrottler:\n    def __init__(self, throttle_ms=200):\n        self.throttle_ms = throttle_ms\n        self.last_scroll_times = {}\n    \n    def can_scroll(self, tab_index):\n        current_time = time.time() * 1000\n        last_time = self.last_scroll_times.get(tab_index, 0)\n        \n        if current_time - last_time >= self.throttle_ms:\n            self.last_scroll_times[tab_index] = current_time\n            return True\n        return False\n\n# åœ¨æ»šåŠ¨å‰æ£€æŸ¥\nscroll_throttler = ScrollThrottler(200)  # 200msèŠ‚æµ\nif scroll_throttler.can_scroll(tab_index):\n    # æ‰§è¡Œæ»šåŠ¨æ“ä½œ\n    pass\nelse:\n    print(f\"æ»šåŠ¨è¢«èŠ‚æµï¼Œè·³è¿‡æ­¤æ¬¡æ“ä½œ\")\n                ",
        "priority": "HIGH"
      }
    ],
    "performance_optimizations": [
      {
        "title": "åå°çº¿ç¨‹å¤„ç†æ»šåŠ¨é€»è¾‘",
        "description": "å°†è€—æ—¶çš„æ»šåŠ¨æ£€æµ‹é€»è¾‘ç§»åˆ°åå°çº¿ç¨‹",
        "implementation": "\nfrom concurrent.futures import ThreadPoolExecutor\nimport threading\n\nclass BackgroundScrollProcessor:\n    def __init__(self):\n        self.executor = ThreadPoolExecutor(max_workers=2, thread_name_prefix=\"ScrollWorker\")\n        self.active_tasks = {}\n    \n    def process_scroll_async(self, tab_index, browser_view, callback):\n        def scroll_task():\n            try:\n                # åœ¨åå°çº¿ç¨‹ä¸­æ‰§è¡Œæ»šåŠ¨æ£€æµ‹é€»è¾‘\n                result = self._check_scroll_status(browser_view)\n                \n                # å›è°ƒåˆ°ä¸»çº¿ç¨‹\n                QTimer.singleShot(0, lambda: callback(result))\n                \n            except Exception as e:\n                QTimer.singleShot(0, lambda: callback({'error': str(e)}))\n        \n        future = self.executor.submit(scroll_task)\n        self.active_tasks[tab_index] = future\n        return future\n                ",
        "priority": "MEDIUM"
      },
      {
        "title": "DOMå…ƒç´ æ™ºèƒ½æ¸…ç†",
        "description": "å®šæœŸæ¸…ç†ä¸å¿…è¦çš„DOMå…ƒç´ ï¼Œé‡Šæ”¾å†…å­˜",
        "implementation": "\nclass DOMCleaner:\n    def __init__(self, cleanup_interval=1000):\n        self.cleanup_interval = cleanup_interval\n        self.processed_count = 0\n    \n    def should_cleanup(self):\n        self.processed_count += 1\n        return self.processed_count % self.cleanup_interval == 0\n    \n    def cleanup_dom(self, browser_view):\n        cleanup_js = '''\n        (function() {\n            // åªä¿ç•™æœ€å100ä¸ªå•†å®¶å…ƒç´ ï¼Œåˆ é™¤å…¶ä»–çš„\n            const merchants = document.querySelectorAll('.Nv2PK');\n            let cleaned = 0;\n            \n            if (merchants.length > 100) {\n                for (let i = 0; i < merchants.length - 100; i++) {\n                    if (merchants[i] && merchants[i].parentNode) {\n                        merchants[i].parentNode.removeChild(merchants[i]);\n                        cleaned++;\n                    }\n                }\n            }\n            \n            // å¼ºåˆ¶åƒåœ¾å›æ”¶\n            if (window.gc) window.gc();\n            \n            return {\n                cleaned: cleaned,\n                remaining: document.querySelectorAll('.Nv2PK').length\n            };\n        })();\n        '''\n        \n        def cleanup_callback(result):\n            if result:\n                print(f\"ğŸ§¹ æ¸…ç†äº†{result.get('cleaned', 0)}ä¸ªDOMå…ƒç´ ï¼Œä¿ç•™{result.get('remaining', 0)}ä¸ª\")\n        \n        browser_view.page().runJavaScript(cleanup_js, cleanup_callback)\n                ",
        "priority": "MEDIUM"
      }
    ],
    "monitoring_additions": [
      {
        "title": "æ»šåŠ¨æ€§èƒ½ç›‘æ§",
        "description": "æ·»åŠ å®æ—¶æ»šåŠ¨æ€§èƒ½ç›‘æ§",
        "implementation": "\nclass ScrollPerformanceMonitor:\n    def __init__(self):\n        self.scroll_metrics = {\n            'total_scrolls': 0,\n            'avg_scroll_time': 0,\n            'max_scroll_time': 0,\n            'ui_freeze_count': 0\n        }\n        self.last_ui_update = time.time()\n    \n    def record_scroll_start(self):\n        self.scroll_start_time = time.time()\n    \n    def record_scroll_end(self):\n        if hasattr(self, 'scroll_start_time'):\n            scroll_duration = time.time() - self.scroll_start_time\n            self.scroll_metrics['total_scrolls'] += 1\n            self.scroll_metrics['avg_scroll_time'] = (\n                (self.scroll_metrics['avg_scroll_time'] * (self.scroll_metrics['total_scrolls'] - 1) + scroll_duration) /\n                self.scroll_metrics['total_scrolls']\n            )\n            self.scroll_metrics['max_scroll_time'] = max(self.scroll_metrics['max_scroll_time'], scroll_duration)\n            \n            if scroll_duration > 2.0:  # è¶…è¿‡2ç§’è§†ä¸ºUIå†»ç»“\n                self.scroll_metrics['ui_freeze_count'] += 1\n                print(f\"âš ï¸ æ£€æµ‹åˆ°UIå†»ç»“: {scroll_duration:.1f}ç§’\")\n    \n    def get_performance_report(self):\n        return f'''\næ»šåŠ¨æ€§èƒ½æŠ¥å‘Š:\n- æ€»æ»šåŠ¨æ¬¡æ•°: {self.scroll_metrics['total_scrolls']}\n- å¹³å‡æ»šåŠ¨æ—¶é—´: {self.scroll_metrics['avg_scroll_time']:.2f}ç§’\n- æœ€å¤§æ»šåŠ¨æ—¶é—´: {self.scroll_metrics['max_scroll_time']:.2f}ç§’\n- UIå†»ç»“æ¬¡æ•°: {self.scroll_metrics['ui_freeze_count']}\n        '''\n                ",
        "priority": "LOW"
      }
    ]
  },
  "integration_guide": "\n# Maps_scraper.py æ»šåŠ¨å¡é¡¿ä¿®å¤é›†æˆæŒ‡å—\n\n## ğŸ”§ ä¿®å¤æ­¥éª¤\n\n### 1. å¤‡ä»½åŸæ–‡ä»¶\n```bash\ncp Maps_scraper.py Maps_scraper.py.backup\n```\n\n### 2. åœ¨GoogleMapsAppç±»çš„__init__æ–¹æ³•ä¸­æ·»åŠ \n```python\ndef __init__(self):\n    # ... ç°æœ‰ä»£ç  ...\n    \n    # æ·»åŠ æ»šåŠ¨æ€§èƒ½ä¼˜åŒ–ç»„ä»¶\n    self.scroll_throttler = ScrollThrottler(200)  # 200msèŠ‚æµ\n    self.background_processor = BackgroundScrollProcessor()\n    self.dom_cleaner = DOMCleaner(1000)  # æ¯å¤„ç†1000ä¸ªå•†å®¶æ¸…ç†ä¸€æ¬¡\n    self.performance_monitor = ScrollPerformanceMonitor()\n    \n    print(\"ğŸš€ [æ»šåŠ¨ä¼˜åŒ–] æ€§èƒ½ä¼˜åŒ–ç»„ä»¶å·²åˆå§‹åŒ–\")\n```\n\n### 3. æ›¿æ¢_scroll_and_waitæ–¹æ³•\n```python\ndef _scroll_and_wait(self, tab_index, current_count):\n    \"\"\"ã€æ€§èƒ½ä¼˜åŒ–ç‰ˆã€‘æ»šåŠ¨åˆ—è¡¨å¹¶ç­‰å¾…æ–°ç»“æœ\"\"\"\n    \n    # æ£€æŸ¥èŠ‚æµ\n    if not self.scroll_throttler.can_scroll(tab_index):\n        print(f\"ğŸ”„ (æ ‡ç­¾é¡µ {tab_index+1}) æ»šåŠ¨è¢«èŠ‚æµï¼Œç¨åé‡è¯•\")\n        QTimer.singleShot(300, lambda: self._scroll_and_wait(tab_index, current_count))\n        return\n    \n    browser_view = self.tabs[tab_index]['view']\n    \n    # è®°å½•æ»šåŠ¨å¼€å§‹\n    self.performance_monitor.record_scroll_start()\n    \n    # å¼‚æ­¥æ‰§è¡Œæ»šåŠ¨\n    def scroll_callback(result):\n        self.performance_monitor.record_scroll_end()\n        self._handle_scroll_result(tab_index, current_count, result)\n    \n    self.background_processor.process_scroll_async(tab_index, browser_view, scroll_callback)\n```\n\n### 4. æ·»åŠ DOMæ¸…ç†æ£€æŸ¥\n```python\ndef after_extraction_and_move_on(self, tab_index):\n    \"\"\"ã€æ”¹é€ ç‰ˆã€‘å¤„ç†å®Œä¸€ä¸ªå•†å®¶åï¼Œç»§ç»­å¤„ç†ä¸‹ä¸€ä¸ª\"\"\"\n    if not self.is_searching or tab_index >= len(self.tabs): \n        return\n    \n    tab_info = self.tabs[tab_index]\n    if tab_info['state'] != 'running': \n        return\n\n    tab_info['current_item_index'] = tab_info.get('current_item_index', 0) + 1\n    \n    # æ£€æŸ¥æ˜¯å¦éœ€è¦DOMæ¸…ç†\n    if self.dom_cleaner.should_cleanup():\n        self.dom_cleaner.cleanup_dom(tab_info['view'])\n    \n    # ç»§ç»­å¤„ç†ä¸‹ä¸€ä¸ªå•†å®¶\n    QTimer.singleShot(100, lambda: self._process_next_item(tab_index))\n```\n\n### 5. æ·»åŠ æ€§èƒ½ç›‘æ§è¾“å‡º\n```python\ndef finish_region_extraction(self, tab_index):\n    \"\"\"ã€æ”¹é€ ç‰ˆã€‘ä¸€ä¸ªåœ°åŒºä»»åŠ¡å®Œæˆåçš„æ ¸å¿ƒå›è°ƒ\"\"\"\n    # ... ç°æœ‰ä»£ç  ...\n    \n    # è¾“å‡ºæ€§èƒ½æŠ¥å‘Š\n    print(self.performance_monitor.get_performance_report())\n    \n    # ... å…¶ä½™ä»£ç ä¸å˜ ...\n```\n\n## ğŸ“Š é¢„æœŸæ•ˆæœ\n\nä¿®å¤ååº”è¯¥è§‚å¯Ÿåˆ°ï¼š\n1. âœ… æ»šåŠ¨æ“ä½œä¸å†é•¿æ—¶é—´é˜»å¡UI\n2. âœ… å†…å­˜ä½¿ç”¨æ›´åŠ ç¨³å®šï¼Œä¸ä¼šæŒç»­å¢é•¿\n3. âœ… æ»šåŠ¨å“åº”æ›´åŠ æµç•…\n4. âœ… ç¨‹åºä¸ä¼šåœ¨æ»šåŠ¨åˆ°åº•éƒ¨æ—¶å¡æ­»\n\n## ğŸ” ç›‘æ§æŒ‡æ ‡\n\né€šè¿‡æ—¥å¿—è§‚å¯Ÿä»¥ä¸‹æŒ‡æ ‡ï¼š\n- æ»šåŠ¨èŠ‚æµæ—¥å¿—ï¼š\"æ»šåŠ¨è¢«èŠ‚æµï¼Œç¨åé‡è¯•\"\n- DOMæ¸…ç†æ—¥å¿—ï¼š\"æ¸…ç†äº†Xä¸ªDOMå…ƒç´ \"\n- UIå†»ç»“è­¦å‘Šï¼š\"æ£€æµ‹åˆ°UIå†»ç»“: Xç§’\"\n- æ€§èƒ½æŠ¥å‘Šï¼šå¹³å‡æ»šåŠ¨æ—¶é—´åº”<1ç§’\n\n## ğŸš¨ æ³¨æ„äº‹é¡¹\n\n1. ä¿®æ”¹åè¯·å…ˆåœ¨å°æ•°æ®é›†ä¸Šæµ‹è¯•\n2. è§‚å¯Ÿå†…å­˜ä½¿ç”¨æƒ…å†µï¼Œç¡®ä¿æ²¡æœ‰å†…å­˜æ³„æ¼\n3. å¦‚æœå‡ºç°é—®é¢˜ï¼Œå¯ä»¥è¿˜åŸå¤‡ä»½æ–‡ä»¶\n4. å¯ä»¥æ ¹æ®å®é™…æƒ…å†µè°ƒæ•´èŠ‚æµæ—¶é—´å’Œæ¸…ç†é¢‘ç‡\n"
}