# Maps_scraper.py 资源优化修复说明

## 🔍 **第二轮问题分析**

经过第一轮死锁修复后，程序仍然出现卡住现象。通过深入分析日志，发现了新的问题：

### 🎯 **根本原因**
1. **资源配置不匹配**: EmailWorker信号量(5个)大于Playwright页面池(3个)，造成资源争抢
2. **页面池资源不足**: 大量并发请求导致页面池快速耗尽
3. **网络请求堆积**: curl_cffi升级到Playwright的请求过多，超出页面池容量
4. **缺乏资源监控**: 无法及时发现资源瓶颈和使用情况

### 📊 **问题表现**
- 日志显示多个"Worker for 'xxx' 已激活伪装身份"
- "[Playwright池] 页面已出队"但很少看到"页面已归队"
- WhatsApp号码提取过程中程序无响应
- 资源使用情况不透明，难以调试

## 🛠️ **第二轮修复方案**

### 1. 🎯 **智能资源配置匹配**

#### 动态调整页面池大小
```python
# 修复前（固定配置）
defaults['playwright_pool_size'] = 3  # 固定3个页面

# 修复后（智能配置）
if total_ram_gb >= 12 and cpu_cores > 8:
    defaults['playwright_pool_size'] = 5  # 高性能系统增加到5个
elif total_ram_gb >= 6 and cpu_cores > 4:
    defaults['playwright_pool_size'] = 3  # 中等性能保持3个
else:
    defaults['playwright_pool_size'] = 2  # 低性能至少2个
```

#### EmailWorker信号量自适应匹配
```python
# 修复前（固定5个）
self.email_worker_semaphore = threading.Semaphore(5)

# 修复后（动态匹配）
semaphore_count = min(self.playwright_pool_size, 5)
self.email_worker_semaphore = threading.Semaphore(semaphore_count)
print(f"📊 [资源配置] EmailWorker信号量: {semaphore_count}, Playwright页面池: {self.playwright_pool_size}")
```

### 2. 📊 **智能页面池监控**

#### 预检查机制
```python
# 修复前（盲目等待）
page = await self.page_pool.get()  # 可能无限等待

# 修复后（智能预检）
current_available = self.page_pool.qsize()
if current_available == 0:
    print(f"⚠️ 页面池资源已满(0/{self.pool_size})，跳过请求")
    return None
else:
    print(f"📊 页面池状态: {current_available}/{self.pool_size} 可用")
```

### 3. 🔧 **网络限流智能调整**

#### 动态并发控制
```python
# 修复前（固定15个并发）
asyncio.Semaphore(15)

# 修复后（基于页面池动态调整）
max_concurrent = min(15, self.playwright_pool_size * 3)  # 每页面最多3个并发
asyncio.Semaphore(max_concurrent)
print(f"✅ 全局网络限流: {max_concurrent} (基于{self.playwright_pool_size}个页面池)")
```

### 4. 📈 **实时资源监控**

#### 周期性状态报告
```python
# 每30秒报告资源使用情况
if current_time - self._last_resource_report > 30:
    active_workers = semaphore_count - self.email_worker_semaphore._value
    queue_size = self.email_task_queue.qsize()
    print(f"📊 [资源监控] 活跃Worker: {active_workers}/{semaphore_count}, 队列任务: {queue_size}")
```

### 5. ⚡ **Worker超时保护**

#### 详细的执行跟踪
```python
# 修复前（简单执行）
result = self.playwright_manager.run_coroutine(self.fetch_email())

# 修复后（全程跟踪）
print(f"🔄 Worker启动: {self.company_name} (行{self.row})")
result = self.playwright_manager.run_coroutine(self.fetch_email())
if result is None:
    print(f"⚠️ Worker超时: {self.company_name} - 可能是页面池繁忙")
    return {'email': "Timeout: 页面池繁忙或网络超时"}, self.row
print(f"✅ Worker完成: {self.company_name}")
```

## ✅ **修复效果预期**

### 🚀 **性能提升**
- **资源匹配**: EmailWorker数量不再超过页面池容量
- **智能调度**: 页面池满时自动跳过请求，避免阻塞
- **动态限流**: 网络并发数根据实际资源动态调整

### 📊 **可观测性提升**
- **实时监控**: 每30秒报告资源使用情况
- **详细日志**: Worker启动、执行、完成全程跟踪
- **状态透明**: 页面池使用情况实时显示

### 🛡️ **稳定性改进**
- **资源保护**: 避免资源耗尽导致的程序卡死
- **智能降级**: 资源不足时优雅跳过而非阻塞
- **超时恢复**: 增强的超时处理和错误恢复

## 🎯 **用户系统优化**

基于您的系统配置（36核CPU, 127GB内存），修复后的配置：
- **Playwright页面池**: 5个页面（高性能配置）
- **EmailWorker信号量**: 5个并发Worker
- **网络并发限制**: 15个并发请求
- **监控频率**: 每30秒报告状态

## 💡 **使用建议**

### 立即生效
修复后程序应该不会再卡死，可以看到详细的资源使用报告。

### 性能调优
如果仍有问题，可以通过日志观察：
1. 页面池使用情况是否平衡
2. Worker超时频率是否过高  
3. 队列任务积压情况

### 故障排除
- 观察"📊 [资源监控]"日志了解资源使用
- 注意"⚠️ 页面池资源已满"的频率
- 监控"Worker超时"的原因分析

---

**修复版本**: 资源优化版 v1.1  
**修复时间**: 2025年9月16日  
**主要改进**: 智能资源配置、实时监控、动态限流